!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).osm2geojson=e()}}(function(){var define,module,exports;return function(){return function e(t,r,s){function n(i,a){if(!r[i]){if(!t[i]){var l="function"==typeof require&&require;if(!a&&l)return l(i,!0);if(o)return o(i,!0);var d=new Error("Cannot find module '"+i+"'");throw d.code="MODULE_NOT_FOUND",d}var f=r[i]={exports:{}};t[i][0].call(f.exports,function(e){return n(t[i][1][e]||e)},f,f.exports,e,t,r,s)}return r[i].exports}for(var o="function"==typeof require&&require,i=0;i<s.length;i++)n(s[i]);return n}}()({1:[function(require,module,exports){const{Node:Node,Way:Way,Relation:Relation}=require("./osmobjs.js"),{purgeProps:purgeProps,RefElements:RefElements}=require("./utils.js"),XmlParser=require("./xmlparser.js");module.exports=((osm,opts)=>{let completeFeature=!1,renderTagged=!1,excludeWay=!0,parseOpts=e=>{if(e){completeFeature=!(!e.completeFeature&&!e.allFeatures),renderTagged=!!e.renderTagged;let t=e.suppressWay||e.excludeWay;void 0===t||t||(excludeWay=!1)}};parseOpts(opts);let detectFormat=e=>e.elements?"json":e.indexOf("<osm")>=0?"xml":e.trim().startsWith("{")?"json-raw":"invalid",format=detectFormat(osm),refElements=new RefElements,featureArray=[],analyzefeaturesFromJson=osm=>{for(let elem of osm.elements)switch(elem.type){case"node":let node=new Node(elem.id,refElements);elem.tags&&node.addTags(elem.tags),node.addProps(purgeProps(elem,["id","type","tags","lat","lon"])),node.setLatLng(elem);break;case"way":let way=new Way(elem.id,refElements);if(elem.tags&&way.addTags(elem.tags),way.addProps(purgeProps(elem,["id","type","tags","nodes","geometry"])),elem.nodes)for(let e of elem.nodes)way.addNodeRef(e);else elem.geometry&&way.setLatLngArray(elem.geometry);break;case"relation":let relation=new Relation(elem.id,refElements);if(elem.bounds)with(elem.bounds)relation.setBounds([parseFloat(minlon),parseFloat(minlat),parseFloat(maxlon),parseFloat(maxlat)]);if(elem.tags&&relation.addTags(elem.tags),relation.addProps(purgeProps(elem,["id","type","tags","bounds","members"])),elem.members)for(let member of elem.members)relation.addMember(member)}},analyzefeaturesFromXml=osm=>{const xmlParser=new XmlParser({progressive:!0});xmlParser.on("</osm.node>",node=>{with(node){let nd=new Node(id,refElements);for(let[k,v]of Object.entries(node))!k.startsWith("$")&&["id","lon","lat"].indexOf(k)<0&&nd.addProp(k,v);if(nd.setLatLng(node),node.$innerNodes)for(let ind of $innerNodes)"tag"===ind.$tag&&nd.addTag(ind.k,ind.v)}}),xmlParser.on("</osm.way>",node=>{with(node){let way=new Way(id,refElements);for(let[k,v]of Object.entries(node))!k.startsWith("$")&&["id"].indexOf(k)<0&&way.addProp(k,v);if(node.$innerNodes)for(let ind of $innerNodes)"nd"===ind.$tag&&(ind.lon&&ind.lat?way.addLatLng(ind):ind.ref?way.addNodeRef(ind.ref):"tag"===ind.$tag&&way.addTag(ind.k,ind.v))}}),xmlParser.on("<osm.relation>",e=>{new Relation(e.id,refElements)}),xmlParser.on("</osm.relation.member>",(node,parent)=>{with(node){let relation=refElements.get(`relation/${parent.id}`),member={type:type,role:node.role?role:"",ref:ref};if(node.lat&&node.lon){member.lat=lat,member.lon=lon,member.tags={};for(let[k,v]of Object.entries(node))!k.startsWith("$")&&["type","lat","lon"].indexOf(k)<0&&(member[k]=v)}if(node.$innerNodes){let geometry=[],nodes=[];for(let ind of $innerNodes)ind.lat&&ind.lon?geometry.push(ind):nodes.push(ind.ref);geometry.length>0?member.geometry=geometry:nodes.length>0&&(member.nodes=nodes)}relation.addMember(member)}}),xmlParser.on("</osm.relation.bounds>",(node,parent)=>{with(node)refElements.get(`relation/${parent.id}`).setBounds([parseFloat(minlon),parseFloat(minlat),parseFloat(maxlon),parseFloat(maxlat)])}),xmlParser.on("</osm.relation.tag>",(e,t)=>{refElements.get(`relation/${t.id}`).addTag(e.k,e.v)}),xmlParser.parse(osm)};"json-raw"===format&&(osm=JSON.parse(osm),format="json"),"json"===format?analyzefeaturesFromJson(osm):"xml"===format&&analyzefeaturesFromXml(osm),refElements.bindAll();for(let v of refElements.values())if(v.refCount<=0||v.hasTag&&renderTagged&&!(v instanceof Way&&excludeWay)){let features=v.toFeatureArray();if(v instanceof Relation&&!completeFeature&&features.length>0)return refElements.cleanup(),features[0].geometry;featureArray=featureArray.concat(features)}return{type:"FeatureCollection",features:featureArray}})},{"./osmobjs.js":2,"./utils.js":4,"./xmlparser.js":5}],2:[function(e,t,r){t.exports=(()=>{"use strict";const{first:t,last:r,coordsToKey:s,addToMap:n,removeFromMap:o,getFirstFromMap:i,isRing:a,ringDirection:l,ptInsidePolygon:d,strToFloat:f,LateBinder:u,WayCollection:h}=e("./utils.js"),p=e("./polytags.json");class m{constructor(e,t,r){this.type=e,this.id=t,this.refElems=r,this.tags={},this.props={id:this.getCompositeId()},this.refCount=0,this.hasTag=!1,r&&r.add(this.getCompositeId(),this)}addTags(e){this.tags=Object.assign(this.tags,e),this.hasTag=!!e}addTag(e,t){this.tags[e]=t,this.hasTag=!!e}addProp(e,t){this.props[e]=t}addProps(e){this.props=Object.assign(this.props,e)}getCompositeId(){return`${this.type}/${this.id}`}getProps(){return Object.assign(this.props,this.tags)}toFeatureArray(){return[]}}class g extends m{constructor(e,t){super("node",e,t),this.latLng=null}setLatLng(e){this.latLng=e}toFeatureArray(){return this.latLng?[{type:"Feature",id:this.getCompositeId(),properties:this.getProps(),geometry:{type:"Point",coordinates:f([this.latLng.lon,this.latLng.lat])}}]:[]}getLatLng(){return this.latLng}}class c extends m{constructor(e,t){super("way",e,t),this.latLngArray=[],this.isPolygon=!1}addLatLng(e){this.latLngArray.push(e)}setLatLngArray(e){this.latLngArray=e}addNodeRef(e){let t=new u(this.latLngArray,function(e){let t=this.refElems.get(`node/${e}`);if(t)return t.refCount++,t.getLatLng()},this,[e]);this.latLngArray.push(t),this.refElems.addBinder(t)}analyzeTag(e,t){let r=p[e];r&&(this.isPolygon=!0,r.whitelist?this.isPolygon=r.whitelist.indexOf(t)>=0:r.blacklist&&(this.isPolygon=!(r.blacklist.indexOf(t)>=0)))}addTags(e){super.addTags(e);for(let[t,r]of Object.entries(e))this.analyzeTag(t,r)}addTag(e,t){super.addTag(e,t),this.analyzeTag(e,t)}toCoordsArray(){return this.latLngArray.map(e=>[e.lon,e.lat])}toFeatureArray(){let e=this.toCoordsArray();if(e.length>1){e=f(e);let t={type:"Feature",id:this.getCompositeId(),properties:this.getProps(),geometry:{type:"LineString",coordinates:e}};return this.isPolygon&&a(e)?("counterclockwise"!==l(e)&&e.reverse(),t.geometry={type:"Polygon",coordinates:[e]},[t]):[t]}return[]}}return{Node:g,Way:c,Relation:class extends m{constructor(e,t){super("relation",e,t),this.relations=[],this.nodes=[],this.bounds=null}setBounds(e){this.bounds=e}addMember(e){switch(e.type){case"relation":let t=new u(this.relations,function(e){let t=this.refElems.get(`relation/${e}`);if(t)return t.refCount++,t},this,[e.ref]);this.relations.push(t),this.refElems.addBinder(t);break;case"way":e.role||e.role;let r=this[e.role];if(r||(r=this[e.role]=[]),e.geometry){let t=new c(e.ref,this.refElems);t.setLatLngArray(e.geometry),t.refCount++,r.push(t)}else if(e.nodes){let t=new c(e.ref,this.refElems);for(let e of nodes)t.addNodeRef(e);t.refCount++,r.push(t)}else{let t=new u(r,function(e){let t=this.refElems.get(`way/${e}`);if(t)return t.refCount++,t},this,[e.ref]);r.push(t),this.refElems.addBinder(t)}break;case"node":let s=null;if(e.lat&&e.lon){(s=new g(e.ref,this.refElems)).setLatLng({lon:e.lon,lat:e.lat}),e.tags&&s.addTags(e.tags);for(let[t,r]of Object.entries(e))["id","type","lat","lon"].indexOf(t)<0&&s.addProp(t,r);s.refCount++,this.nodes.push(s)}else{let t=new u(this.nodes,function(e){let t=this.refElems.get(`node/${e}`);if(t)return t.refCount++,t},this,[e.ref]);this.nodes.push(t),this.refElems.addBinder(t)}}}toFeatureArray(){let e=[],r=[],s=[];const n=["outer","inner",""];for(let e of this.relations)if(e)for(let t of n){let r=e[t];if(r){let e=this[t];e?[].splice.apply(e,[e.length,0].concat(r)):this[t]=r}}for(let e of n){let t=this[e];if(t){this[e]=new h;for(let r of t)this[e].addWay(r)}}let o=null,i={type:"Feature",id:this.getCompositeId(),bbox:this.bounds,properties:this.getProps()};this.bounds||delete i.bbox,this.outer?(o=((e,r)=>{let s=e?e.toRings("counterclockwise"):[],n=r?r.toRings("clockwise"):[];if(s.length>0){let e=[],r=null;for(r of s)e.push([r]);for(;r=n.shift();)for(let n in s)if(d(t(r),s[n])){e[n].push(r);break}return 1===e.length?{type:"Polygon",coordinates:e[0]}:{type:"MultiPolygon",coordinates:e}}return null})(this.outer,this.inner))&&(i.geometry=o,e.push(i)):this[""]&&(o=(e=>{let t=e?e.toStrings():[];return t.length>0?1===t.length?{type:"LineString",coordinates:t[0]}:{type:"MultiLineString",coordinates:t}:null})(this[""]))&&(i.geometry=o,r.push(i));for(let e of this.nodes)s=s.concat(e.toFeatureArray());return e.concat(r).concat(s)}}}})()},{"./polytags.json":3,"./utils.js":4}],3:[function(e,t,r){t.exports={building:{},highway:{whitelist:["services","rest_area","escape","elevator"]},natural:{blacklist:["coastline","cliff","ridge","arete","tree_row"]},landuse:{},waterway:{whitelist:["riverbank","dock","boatyard","dam"]},amenity:{},leisure:{},barrier:{whitelist:["city_wall","ditch","hedge","retaining_wall","wall","spikes"]},railway:{whitelist:["station","turntable","roundhouse","platform"]},area:{},boundary:{},man_made:{blacklist:["cutline","embankment","pipeline"]},power:{whitelist:["plant","substation","generator","transformer"]},place:{},shop:{},aeroway:{blacklist:["taxiway"]},tourism:{},historic:{},public_transport:{},office:{},"building:part":{},military:{},ruins:{},"area:highway":{},craft:{},golf:{},indoor:{}}},{}],4:[function(e,t,r){t.exports=(()=>{"use strict";const e=e=>e[0],t=e=>e[e.length-1],r=e=>e.join(","),s=(e,t,r)=>{let s=e[t];s?s.push(r):e[t]=[r]},n=(e,t,r)=>{let s=e[t],n=null;s&&(n=s.indexOf(r))>=0&&s.splice(n,1)},o=(e,t)=>{let r=e[t];return r&&r.length>0?r[0]:null},i=s=>s.length>3&&r(e(s))===r(t(s)),a=(e,t,r)=>{t=t||0,r=r||1;let s=e.reduce((r,s,n)=>e[r][t]>s[t]?r:n,0),n=s<=0?e.length-2:s-1,o=s>=e.length-1?1:s+1,i=e[n][t],a=e[s][t],l=e[o][t],d=e[n][r],f=e[s][r];return(a-i)*(e[o][r]-d)-(l-i)*(f-d)<0?"clockwise":"counterclockwise"},l=e=>e instanceof Array?e.map(l):parseFloat(e);return{purgeProps:(e,t)=>{if(e){let r=Object.assign({},e);if(t)for(let e of t)delete r[e];return r}return{}},mergeProps:(e,t)=>(e=e||{},t=t||{},Object.assign(e,t)),first:e,last:t,coordsToKey:r,addToMap:s,removeFromMap:n,getFirstFromMap:o,isRing:i,ringDirection:a,ptInsidePolygon:(e,t,r,s)=>{r=r||0,s=s||1;let n=!1;for(let o=0,i=t.length-1;o<t.length;i=o++)(t[o][r]<=e[r]&&e[r]<t[i][r]||t[i][r]<=e[r]&&e[r]<t[o][r])&&e[s]<(t[i][s]-t[o][s])*(e[r]-t[o][r])/(t[i][r]-t[o][r])+t[o][s]&&(n=!n);return n},strToFloat:l,RefElements:class extends Map{constructor(){super(),this.binders=[]}add(e,t){if(this.has(e))throw`Error: adding duplicated key '${e}' to RefElements`;this.set(e,t)}addBinder(e){this.binders.push(e)}bindAll(){this.binders.forEach(e=>e.bind())}},LateBinder:class{constructor(e,t,r,s){this.container=e,this.valueFunc=t,this.ctx=r,this.args=s}bind(){let e=this.valueFunc.apply(this.ctx,this.args);if(this.container instanceof Array){let t=this.container.indexOf(this);if(t>=0){let r=[t,1];e&&r.push(e),[].splice.apply(this.container,r)}}else if("object"==typeof this.container){let t=Object.keys(this.container).find(e=>this.container[e]===this);t&&(e?this.container[t]=e:delete this.container[t])}}},WayCollection:class extends Array{constructor(){super(),this.firstMap={},this.lastMap={}}addWay(n){(n=n.toCoordsArray()).length>0&&(this.push(n),s(this.firstMap,r(e(n)),n),s(this.lastMap,r(t(n)),n))}toStrings(){let s=[],i=null;for(;i=this.shift();){n(this.firstMap,r(e(i)),i),n(this.lastMap,r(t(i)),i);let a=i,d=null;do{let s=r(t(a)),i=!1;(d=o(this.firstMap,s))||(d=o(this.lastMap,s),i=!0),d&&(this.splice(this.indexOf(d),1),n(this.firstMap,r(e(d)),d),n(this.lastMap,r(t(d)),d),i&&(d.length>a.length&&([a,d]=[d,a]),d.reverse()),a=a.concat(d.slice(1)))}while(d);s.push(l(a))}return s}toRings(e){let t=this.toStrings(),r=[],s=null;for(;s=t.shift();)i(s)&&(a(s)!==e&&s.reverse(),r.push(s));return r}}}})()},{}],5:[function(e,t,r){t.exports=(()=>{"use strict";function e(e){return null!=e.match(/^(.+?)\[(.+?)\]>$/g)}function t(e){let t=/^(.+?)\[(.+?)\]>$/g.exec(e);return t?{evt:t[1]+">",exp:t[2]}:{evt:e}}return class{constructor(e){e&&(this.queryParent=!!e.queryParent,this.progressive=e.progressive,this.queryParent&&(this.parentMap=new WeakMap)),this.evtListeners={}}parse(e,t,r){r=r?r+".":"";let s=/<([^ >\/]+)(.*?)>/gm,n=null,o=[];for(;n=s.exec(e);){let i=n[1],a={$tag:i},l=r+i,d=n[2].trim(),f=!1;(d.endsWith("/")||i.startsWith("?")||i.startsWith("!"))&&(f=!0);let u=/([^ ]+?)="(.+?)"/g,h=/([^ ]+?)='(.+?)'/g,p=null,m=!1;for(;p=u.exec(d);)m=!0,a[p[1]]=p[2];if(!m)for(;p=h.exec(d);)m=!0,a[p[1]]=p[2];if(m||""===d||(a.text=d),this.progressive&&this.emit(`<${l}>`,a,t),!f){let t=new RegExp(`([^]+?)</${i}>`,"g");t.lastIndex=s.lastIndex;let r=t.exec(e);if(r&&r[1]){s.lastIndex=t.lastIndex;let e=this.parse(r[1],a,l);e.length>0?a.$innerNodes=e:a.$innerText=r[1]}}this.queryParent&&t&&this.parentMap.set(a,t),this.progressive&&this.emit(`</${l}>`,a,t),o.push(a)}return o}getParent(e){return this.queryParent?this.parentMap.get(e):null}$addListener(e,t){let r=this.evtListeners[e];r?r.push(t):this.evtListeners[e]=[t]}addListener(r,s){e(r)&&(r=t(r),s.condition=function(e){let t="return "+e.replace(/(\$.+?)(?=[=!.])/g,"node.$&")+";";return new Function("node",t)}(r.exp),r=r.evt),this.$addListener(r,s)}$removeListener(e,t){let r=this.evtListeners[e],s=null;r&&(s=r.indexOf(t))>=0&&r.splice(s,1)}removeListener(r,s){e(r)&&(r=(r=t(r)).evt),this.$removeListener(r,s)}emit(e,...t){let r=this.evtListeners[e];if(r)for(let e of r)e.condition?!0===e.condition.apply(null,t)&&e.apply(null,t):e.apply(null,t)}on(e,t){this.addListener(e,t)}off(e,t){this.removeListener(e,t)}}})()},{}]},{},[1])(1)});