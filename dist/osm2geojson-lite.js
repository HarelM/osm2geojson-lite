!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).osm2geojson=e()}}(function(){var define,module,exports;return function(){return function e(t,r,s){function o(i,a){if(!r[i]){if(!t[i]){var l="function"==typeof require&&require;if(!a&&l)return l(i,!0);if(n)return n(i,!0);var d=new Error("Cannot find module '"+i+"'");throw d.code="MODULE_NOT_FOUND",d}var f=r[i]={exports:{}};t[i][0].call(f.exports,function(e){return o(t[i][1][e]||e)},f,f.exports,e,t,r,s)}return r[i].exports}for(var n="function"==typeof require&&require,i=0;i<s.length;i++)o(s[i]);return o}}()({1:[function(require,module,exports){const{Node:Node,Way:Way,Relation:Relation}=require("./osmobjs.js"),{purgeProps:purgeProps,RefElements:RefElements}=require("./utils.js"),XmlParser=require("./xmlparser.js");module.exports=((osm,opts)=>{let completeFeature=!1,renderTagged=!1,excludeWay=!0,parseOpts=e=>{if(e){completeFeature=!(!e.completeFeature&&!e.allFeatures),renderTagged=!!e.renderTagged;let t=e.suppressWay||e.excludeWay;void 0===t||t||(excludeWay=!1)}};parseOpts(opts);let refElements=new RefElements,featureArray=[],analyzefeaturesFromJson=osm=>{for(let elem of osm.elements)switch(elem.type){case"node":let node=new Node(elem.id,refElements);elem.tags&&node.addTags(elem.tags),node.addProps(purgeProps(elem,["id","type","tags","lat","lon"])),node.setCoords([elem.lon,elem.lat]);break;case"way":let way=new Way(elem.id,refElements);if(elem.tags&&way.addTags(elem.tags),way.addProps(purgeProps(elem,["id","type","tags","nodes","geometry"])),elem.nodes)for(let e of elem.nodes)way.addNodeRef(e);else if(elem.geometry)for(let e of elem.geometry)way.addCoords([e.lon,e.lat]);break;case"relation":let relation=new Relation(elem.id,refElements);if(elem.bounds)with(elem.bounds)relation.addProp("bbox",[parseFloat(minlon),parseFloat(minlat),parseFloat(maxlon),parseFloat(maxlat)]);if(elem.tags&&relation.addTags(elem.tags),relation.addProps(purgeProps(elem,["id","type","tags","bounds","members"])),elem.members)for(let member of elem.members)relation.addMember(member)}},analyzefeaturesFromXml=osm=>{const xmlParser=new XmlParser({progressive:!0});xmlParser.on("</osm.node>",node=>{with(node){let nd=new Node(node.$id,refElements);for(let[k,v]of Object.entries(node))k.startsWith("$")&&["$id","$lon","$lat"].indexOf(k)<0&&nd.addProp(k.substring(1),v);if(nd.setCoords([$lon,$lat]),node.innerNodes)for(let ind of innerNodes)"tag"===ind.tag&&nd.addTag(ind.$k,ind.$v)}}),xmlParser.on("</osm.way>",node=>{with(node){let way=new Way($id,refElements);for(let[k,v]of Object.entries(node))k.startsWith("$")&&["$id"].indexOf(k)<0&&way.addProp(k.substring(1),v);if(node.innerNodes)for(let ind of innerNodes)ind.$lon&&ind.$lat?way.addCoords([ind.$lon,ind.$lat]):ind.$ref?way.addNodeRef(ind.$ref):"tag"===ind.tag&&way.addTag(ind.$k,ind.$v)}}),xmlParser.on("<osm.relation>",e=>{new Relation(e.$id,refElements)}),xmlParser.on("</osm.relation.member>",(node,parent)=>{with(node){let relation=refElements[parent.$id],member={type:$type,role:node.$role?$role:"",ref:$ref};if(node.$lat&&node.$lon){member.lat=$lat,member.lon=$lon,member.tags={};for(let[k,v]of Object.entries(node))k.startsWith("$")&&["$type","$lat","$lon"].indexOf(k)<0&&(member[k.substring(1)]=v)}if(node.innerNodes){let geometry=[],nodes=[];for(let ind of innerNodes)ind.$lat&&ind.$lon?geometry.push({lat:ind.$lat,lon:ind.$lon}):nodes.push(ind.$ref);geometry.length>0?member.geometry=geometry:nodes.length>0&&(member.nodes=nodes)}relation.addMember(member)}}),xmlParser.on("</osm.relation.bounds>",(node,parent)=>{with(node)refElements[parent.$id].addProp("bbox",[parseFloat($minlon),parseFloat($minlat),parseFloat($maxlon),parseFloat($maxlat)])}),xmlParser.on("</osm.relation.tag>",(e,t)=>{refElements[t.$id].addTag(e.$k,e.$v)}),xmlParser.parse(osm)};osm.elements?analyzefeaturesFromJson(osm):analyzefeaturesFromXml(osm);for(let[k,v]of Object.entries(refElements))if(v&&(v.refCount<=0||renderTagged&&v.hasTag&&!(v instanceof Way&&excludeWay)))if(v.toFeature){let feature=v.toFeature();feature&&featureArray.push(feature)}else if(v.toFeatureArray&&(featureArray=featureArray.concat(v.toFeatureArray()),!completeFeature&&featureArray.length>0))return refElements.cleanup(),featureArray[0].geometry;return refElements.cleanup(),{type:"FeatureCollection",features:featureArray}})},{"./osmobjs.js":2,"./utils.js":4,"./xmlparser.js":5}],2:[function(e,t,r){t.exports=(()=>{"use strict";const{first:t,last:r,coordsToKey:s,addToMap:o,removeFromMap:n,getFirstFromMap:i,isRing:a,ringDirection:l,ptInsidePolygon:d,strToFloat:f,LateBinder:u,WayCollection:h}=e("./utils.js"),p=e("./polytags.json");class c{constructor(e,t,r){this.type=e,this.id=t,this.refElems=r,this.tags={},this.props={id:this.getCompositeId()},this.refCount=0,this.hasTag=!1,r&&r.add(t,this)}addTags(e){this.tags=Object.assign(this.tags,e),this.hasTag=!!e}addTag(e,t){this.tags[e]=t,this.hasTag=!!e}addProp(e,t){this.props[e]=t}addProps(e){this.props=Object.assign(this.props,e)}getCompositeId(){return`${this.type}/${this.id}`}getProps(){return Object.assign(this.props,this.tags)}unlinkRef(){this.refElems=null}}class m extends c{constructor(e,t){super("node",e,t),this.coords=null}setCoords(e){e instanceof Array&&(this.coords=e)}toFeature(){if(this.coords)return{type:"Feature",id:this.getCompositeId(),properties:this.getProps(),geometry:{type:"Point",coordinates:f(this.coords)}}}getCoords(){return this.coords}}class g extends c{constructor(e,t){super("way",e,t),this.coordsArray=[],this.isPolygon=!1,this.isBound=!1}addCoords(e){this.coordsArray.push(e)}addNodeRef(e){this.coordsArray.push(new u(this.coordsArray,function(e){let t=this.refElems[e];if(t)return t.refCount++,t.getCoords()},this,[e]))}analyzeTag(e,t){let r=p[e];r&&(this.isPolygon=!0,r.whitelist?this.isPolygon=r.whitelist.indexOf(t)>=0:r.blacklist&&(this.isPolygon=!(r.blacklist.indexOf(t)>=0)))}addTags(e){super.addTags(e);for(let[t,r]of Object.entries(e))this.analyzeTag(t,r)}addTag(e,t){super.addTag(e,t),this.analyzeTag(e,t)}bindRefs(){this.isBound||(this.coordsArray.reduce((e,t)=>t instanceof u?e.concat([t]):e,[]).forEach(e=>e.bind()),this.isBound=!0)}toCoordsArray(){return this.bindRefs(),this.coordsArray}toFeature(){if(this.bindRefs(),this.coordsArray.length>1)return this.isPolygon&&a(this.coordsArray)?("counterclockwise"!==l(this.coordsArray)&&this.coordsArray.reverse(),{type:"Feature",id:this.getCompositeId(),properties:this.getProps(),geometry:{type:"Polygon",coordinates:[f(this.coordsArray)]}}):{type:"Feature",id:this.getCompositeId(),properties:this.getProps(),geometry:{type:"LineString",coordinates:f(this.coordsArray)}}}}return{Node:m,Way:g,Relation:class extends c{constructor(e,t){super("relation",e,t),this.relations=[],this.nodes=[],this.isBound=!1}addMember(e){switch(e.type){case"relation":this.relations.push(new u(this.relations,function(e){let t=this.refElems[e];if(t)return t.refCount++,t},this,[e.ref]));break;case"way":e.role||e.role;let t=this[e.role];if(t||(t=this[e.role]=[]),e.geometry){let r=new g(e.ref,this.refElems);for(let t of e.geometry)r.addCoords([t.lon,t.lat]),r.refCount++;t.push(r)}else if(e.nodes){let r=new g(e.ref,this.refElems);for(let e of nodes)r.addNodeRef(e),r.refCount++;t.push(r)}else t.push(new u(t,function(e){let t=this.refElems[e];if(t)return t.refCount++,t},this,[e.ref]));break;case"node":let r=null;if(e.lat&&e.lon){(r=new m(e.ref,this.refElems)).setCoords([e.lon,e.lat]),e.tags&&r.addTags(e.tags);for(let[t,s]of Object.entries(e))"id"!==t&&"type"!==t&&"lat"!==t&&"lon"!==t&&r.addProp(t,s);r.refCount++,this.nodes.push(r)}else this.nodes.push(new u(this.nodes,function(e){let t=this.refElems[e];if(t)return t.refCount++,t},this,[e.ref]))}}bindRefs(){if(!this.isBound){const e=["relations","nodes","outer","inner",""];for(let t of e){let e=this[t];if(e&&e.length>0){let t=e.slice(0);for(let e of t)e instanceof u?e.bind():e.bindRefs&&e.bindRefs()}}this.isBound=!0}}toFeatureArray(){this.bindRefs();let e=[],r=[],s=[];const o=["outer","inner",""];for(let e of this.relations)if(e){e.bindRefs();for(let t of o){let r=e[t];if(r){let e=this[field];e?[].splice.apply(e,[e.length,0].concat(r)):this[t]=r}}}for(let e of o){let t=this[e];if(t){this[e]=new h;for(let r of t)this[e].addWay(r)}}let n=null;this.outer?(n=((e,r)=>{let s=e?e.toRings("counterclockwise"):[],o=r?r.toRings("clockwise"):[];if(s.length>0){let e=[],r=null;for(r of s)e.push([r]);for(;r=o.shift();)for(let o in s)if(d(t(r),s[o])){e[o].push(r);break}return 1===e.length?{type:"Polygon",coordinates:e[0]}:{type:"MultiPolygon",coordinates:e}}return null})(this.outer,this.inner))&&e.push({type:"Feature",id:this.getCompositeId(),properties:this.getProps(),geometry:n}):this[""]&&(n=(e=>{let t=e?e.toStrings():[];return t.length>0?1===t.length?{type:"LineString",coordinates:t[0]}:{type:"MultiLineString",coordinates:t}:null})(this[""]))&&r.push({type:"Feature",id:this.getCompositeId(),properties:this.getProps(),geometry:n});for(let e of this.nodes)s.push(e.toFeature());return e.concat(r).concat(s)}}}})()},{"./polytags.json":3,"./utils.js":4}],3:[function(e,t,r){t.exports={building:{},highway:{whitelist:["services","rest_area","escape","elevator"]},natural:{blacklist:["coastline","cliff","ridge","arete","tree_row"]},landuse:{},waterway:{whitelist:["riverbank","dock","boatyard","dam"]},amenity:{},leisure:{},barrier:{whitelist:["city_wall","ditch","hedge","retaining_wall","wall","spikes"]},railway:{whitelist:["station","turntable","roundhouse","platform"]},area:{},boundary:{},man_made:{blacklist:["cutline","embankment","pipeline"]},power:{whitelist:["plant","substation","generator","transformer"]},place:{},shop:{},aeroway:{blacklist:["taxiway"]},tourism:{},historic:{},public_transport:{},office:{},"building:part":{},military:{},ruins:{},"area:highway":{},craft:{},golf:{},indoor:{}}},{}],4:[function(e,t,r){t.exports=(()=>{"use strict";let e=e=>e[0],t=e=>e[e.length-1],r=e=>e.join(","),s=(e,t,r)=>{let s=e[t];s?s.push(r):e[t]=[r]},o=(e,t,r)=>{let s=e[t];s&&s.splice(s.indexOf(r),1)},n=(e,t)=>{let r=e[t];return r&&r.length>0?r[0]:null},i=s=>s.length>2&&r(e(s))===r(t(s)),a=(e,t,r)=>{t=t||0,r=r||1;let s=e.reduce((r,s,o)=>e[r][t]>s[t]?r:o,0),o=s<=0?e.length-1:s-1,n=s>=e.length-1?0:s+1,i=e[o][t],a=e[s][t],l=e[n][t],d=e[o][r],f=e[s][r];return(a-i)*(e[n][r]-d)-(l-i)*(f-d)<0?"clockwise":"counterclockwise"},l=e=>e instanceof Array?e.map(l):parseFloat(e);return{purgeProps:(e,t)=>{if(e){let r=Object.assign({},e);for(let e of t)delete r[e];return r}return{}},mergeProps:(e,t)=>(e=e||{},t=t||{},Object.assign(e,t)),first:e,last:t,coordsToKey:r,addToMap:s,removeFromMap:o,getFirstFromMap:n,isRing:i,ringDirection:a,ptInsidePolygon:(e,t,r,s)=>{r=r||0,s=s||1;let o=!1;for(let n=0,i=t.length-1;n<t.length;i=n++)(t[n][r]<=e[r]&&e[r]<t[i][r]||t[i][r]<=e[r]&&e[r]<t[n][r])&&e[s]<(t[i][s]-t[n][s])*(e[r]-t[n][r])/(t[i][r]-t[n][r])+t[n][s]&&(o=!o);return o},strToFloat:l,RefElements:class{add(e,t){this[e]=t}cleanup(){for(let[e,t]of Object.entries(this))t&&t.unlinkRef&&t.unlinkRef(),delete this[e]}},LateBinder:class{constructor(e,t,r,s){this.container=e,this.valueFunc=t,this.ctx=r,this.args=s}bind(){let e=this.valueFunc.apply(this.ctx,this.args);if(this.container instanceof Array){let t=[this.container.indexOf(this),1];e&&t.push(e),[].splice.apply(this.container,t)}else if("object"==typeof this.container){let t=Object.keys(this.container).find(e=>this.container[e]===this);t&&(e?this.container[t]=e:delete this.container[t])}}},WayCollection:class extends Array{constructor(){super(),this.firstMap={},this.lastMap={}}addWay(o){o=o.toCoordsArray(),this.push(o),s(this.firstMap,r(e(o)),o),s(this.lastMap,r(t(o)),o)}toStrings(){let s=[],i=null;for(;i=this.shift();){o(this.firstMap,r(e(i)),i),o(this.lastMap,r(t(i)),i);let a=i,d=null;do{let s=r(t(a)),i=!1;(d=n(this.firstMap,s))||(d=n(this.lastMap,s),i=!0),d&&(this.splice(this.indexOf(d),1),o(this.firstMap,r(e(d)),d),o(this.lastMap,r(t(d)),d),i&&(d.length>a.length&&([a,d]=[d,a]),d.reverse()),a=a.concat(d.slice(1)))}while(d);s.push(l(a))}return s}toRings(e){let t=this.toStrings(),r=[],s=null;for(;s=t.shift();)i(s)&&(a(s)!=e&&s.reverse(),r.push(s));return r}}}})()},{}],5:[function(e,t,r){t.exports=(()=>{"use strict";function e(e){return null!=e.match(/^(.+?)\[(.+?)\]>$/g)}function t(e){let t=/^(.+?)\[(.+?)\]>$/g.exec(e);return t?{evt:t[1]+">",exp:t[2]}:{evt:e}}return class{constructor(e){e&&(this.queryParent=!!e.queryParent,this.progressive=e.progressive,this.queryParent&&(this.parentMap=new WeakMap)),this.evtListeners={}}parse(e,t,r){r=r?r+".":"";let s=/<([^ >\/]+)(.*?)>/gm,o=null,n=[];for(;o=s.exec(e);){let i=o[1],a={tag:i},l=r+i,d=o[2].trim(),f=!1;(d.endsWith("/")||i.startsWith("?")||i.startsWith("!"))&&(f=!0);let u=/([^ ]+?)="(.+?)"/g,h=/([^ ]+?)='(.+?)'/g,p=null,c=!1;for(;p=u.exec(d);)c=!0,a[`$${p[1]}`]=p[2];if(!c)for(;p=h.exec(d);)c=!0,a[`$${p[1]}`]=p[2];if(c||""===d||(a.text=d),this.progressive&&this.emit(`<${l}>`,a,t),!f){let t=new RegExp(`([^]+?)</${i}>`,"g");t.lastIndex=s.lastIndex;let r=t.exec(e);if(r&&r[1]){s.lastIndex=t.lastIndex;let e=this.parse(r[1],a,l);e.length>0?a.innerNodes=e:a.innerText=r[1]}}this.queryParent&&t&&this.parentMap.set(a,t),this.progressive&&this.emit(`</${l}>`,a,t),n.push(a)}return n}getParent(e){return this.queryParent?this.parentMap.get(e):null}$addListener(e,t){let r=this.evtListeners[e];r?r.push(t):this.evtListeners[e]=[t]}addListener(r,s){e(r)&&(r=t(r),s.condition=function(e){let t="return "+e.replace(/(\$.+?)(?=[=!.])/g,"node.$&")+";";return new Function("node",t)}(r.exp),r=r.evt),this.$addListener(r,s)}$removeListener(e,t){let r=this.evtListeners[e];r&&r.splice(r.indexOf(t),1)}removeListener(r,s){e(r)&&(r=(r=t(r)).evt),this.$removeListener(r,s)}emit(e,...t){let r=this.evtListeners[e];if(r)for(let e of r)e.condition?!0===e.condition.apply(null,t)&&e.apply(null,t):e.apply(null,t)}on(e,t){this.addListener(e,t)}off(e,t){this.removeListener(e,t)}}})()},{}]},{},[1])(1)});